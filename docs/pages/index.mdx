---
title: "Introduction"
lang: en-US
description: "Introduction to the Nexus documentation"
image: "/nexus-head.png"
---

# Introduction

<br />

import Image from "next/image";

<Image
  src="/nexus-head.png"
  alt="Nexus Labs Banner"
  width={1000}
  height={1000}
  style={{ borderRadius: "10px" }}
/>

<br />

<div style={{textAlign: "center"}}>
Welcome to the Nexus docs.
</div>

---

# The Nexus zkVM

The Nexus zkVM is a machine designed to prove abitrary computations. It allows anyone to generate zero-knowledge proofs for programs written in Rust. It is designed for simplicity, safety and performance.

## The Nexus Virtual Machine

The Nexus zkVM proves executions against any CPU architecture (e.g. RISC-V, Wasm, EVM, etc.) through compilation against the Nexus Virtual Machine, a minimal CPU architecture designed to deliver maximum prover efficiency.

## Design Principles

The Nexus zkVM is designed with the following principles:

- Simplicity:
  - Generating and verifying zero-knowledge proofs should be as easy as `nexus prove` and `nexus verify`.
- Universality:
  - The zkVM can prove _any_ computation, for any programming language (e.g. Rust, C++, Go), any machine architecture (e.g. RISC-V, Wasm, EVM), and any circuit arithmetization (e.g. R1CS, Plonkish, AIR).
- Incrementality:
  - The zkVM has no bounds on the size of the programs it can prove. Further, the proofs themselves are updatable.
- Ultra-high Performance:
  - The zkVM is designed to be massively-parallelizable, and is currently designed only to be practical for really large programs (> 1B CPU cycles).
- Cryptography-Opinionated:
  - The Nexus team makes deliberate and precise choices in the cryptography behind the zkVM prover, elliptic curves, proof systems, compression sequence, parallelization strategy, security properties, parameters, etc. to ensure maximum performance and security to developers.
- Extensibility and modularity:
  - The zkVM is designed to enrich the open-source community and be developer-first to ensure extensibility: it can easily be extended with custom instructions (e.g. SHA-256), new compilation toolchains, and can be adapted to prove new programming languages and CPU architectures.
