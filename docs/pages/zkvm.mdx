---
title: "Nexus-zkVM Specification"
lang: en-US
description: "A description of the Nexus Zero-Knowledge Virtual Machine."
image: "/nexus-head.png"
---

# Introduction


# Nexus Zero-Knowledge Virtual Machine
The *Nexus Zero-Knowledge Virtual Machine* (***Nexus zkVM*** for short) is a general computing platform allowing programs to be executed in a verifiable way.  The Nexus zkVM architecture has two main components: the *Nexus Virtual Machine* and the *Nexus Proof System*.

The Nexus zkVM provides not only a general computing platform on which programs written in other languages can be compiled to run, but also a unified computing paradigm enabling the generation of accurate claims and proofs about the correctness of the computation.

Being inspired by the RISC-V ISA [[WLPA14](#References)] and the vnTinyRAM architecture [[CGTV20](#References)], the Nexus VM can be easily translated from the RISC-V instruction set, for which a rich set of compilation tools already exists. As a result, the Nexus zkVM can easily support the verifiable execution of programs written in high-level programming languages such as Rust and C++. Support for other machine architectures such as EVM and Wasm can be provided through translation, emulation, or native execution.

The first iteration of the Nexus Virtual Machine provides support for circuits encoded in Rank-1 Constraint Satisfiability (R1CS). Future versions of the Nexus zkVM will provide support for user-defined circuits encoded in CCS [[STW23](#References)], a modern encoding that simultaneously captures R1CS, Plonkish, and AIR. 

## Nexus Virtual Machine

The Nexus Virtual Machine (Nexus VM) is a reduced instruction set computer (RISC) with a word-addressable random-access memory and input tapes. This virtual machine abstraction is comparable to others used in the zero-knowledge research space, such as the [TinyRAM architecture specification][TinyRAM]. The advantage of using such random-access machines is that they abstract away details of the underlying hardware or operating system and provide a convenient tool for generating claims and proofs about the correctness of a computation.

### Nexus Virtual Machine Architecture

The Nexus Virtual Machine has a *von Neumann* architecture, storing instructions and data in the same read-write memory space.  The machine has 32 registers and a read-write memory with addresses in the range $\{0\ldots 2^{32}\}$.   The state of the machine is defined as a five-tuple, $(pc;M;R;I;W)$, where
* $pc$ denotes the program counter register;
* $M$ denotes the memory;
* $R$ denotes the set of registers;
* $I$ is the public input;
* $W$ is an auxiliary input, seen as a nondeterministic advice.

<center>
![An abstraction of the Nexus Virtual Machine](/images/nvm-architecture.svg)
</center>

Both $M$ and $R$ are finite maps. The memory $M$ can, at any given state, be viewed as a partial map from addresses in the range $\{0,\ldots, 2^{32}-1\}$ to 32-bit words. There are 32 registers named $\{x_0\ldots x_{31}\}$. By design, updates to register $x_0$ are ignored and the value of $R[x_0]$ is always zero. Though the current implementation of the Nexus VM does not support public and auxiliary/private inputs, this will soon be available.

At initialization, all the general-purpose registers are set to 0. The program counter $pc$ is set to $\mathtt{0x1000}$. The input and auxiliary tapes, once supported, should contain the public and input auxiliary inputs for the program. Since $pc$ is initially $\mathtt{0x1000}$, the first instruction to be executed will be the one stored at the position $\mathtt{0x1000}$ of the memory. Since the program code resides in the same area as the data, the initial memory can contain not only the program code but also some initial input data for the program.

There are 30 instructions in total in the instruction set of the Nexus VM, as summarized in table below. Each instruction is specified via an **opcode** and takes three arguments, two register selectors and a full 32-bit immediate value. The exact format $(\textbf{opcode}\;rd\;\;rs_1\;rs_2\;i)$ of each instruction is defined as follows: 
* $\textbf{opcode}$ is a string defining the instruction;
* $rd$ is a register selector specifying the destination register;
* $rs_1$ is a register selector specifying the first operand;
* $rs_2$ is a register selector specifying the second operand; and
* $i$ is a full 32-bit immediate value.

Table: Summary of the Nexus Virtual Machine Instruction Set.
| Instruction mnemonic| Arguments | Description of functionality |
| -------- | -------- | -------- |
| $\textbf{add}$     | $rd$ $rs_1$  $rs_2$  $i$     | sets $rd$ to $R[rs_1] + (R[rs_2] + i)$     |
| $\textbf{sub}$ | $rd$ $rs_1$  $rs_2$  $i$ | sets $rd$ to $R[rs_1] - (R[rs_2] + i)$| 
| $\textbf{mul}$ | $rd$ $rs_1$  $rs_2$  $i$ | sets $rd$ to the least significant bits of $R[rs_1] \times (R[rs_2] + i)$| 
| $\textbf{div}$ | $rd$ $rs_1$  $rs_2$  $i$ | sets $rd$ to the quotient of $R[rs_1] / (R[rs_2] + i)$|  % What if $R[rs_2] + i) = 0$?
| $\textbf{slt}$ | $rd$ $rs_1$  $rs_2$  $i$ | sets $rd$ to $(R[rs_1] < (R[rs_2] + i)$ (signed comparison) | 
| $\textbf{sltu}$ | $rd$ $rs_1$  $rs_2$  $i$ | sets $rd$ to $(R[rs_1] < (R[rs_2] + i)$ (unsigned comparison)| 
| $\textbf{sll}$ | $rd$ $rs_1$  $rs_2$  $i$ | sets $rd$ to $R[rs_1] \ll (R[rs_2] + i) \mathbin{\&} \mathtt{0x1F}$| 
| $\textbf{slr}$ | $rd$ $rs_1$  $rs_2$  $i$ | sets $rd$ to $R[rs_1] \gg (R[rs_2] + i) \mathbin{\&} \mathtt{0x1F}$| 
| $\textbf{sra}$ | $rd$ $rs_1$  $rs_2$  $i$ | sets $rd$ to $R[rs_1] \gg (R[rs_2] + i) \mathbin{\&} \mathtt{0x1F}$ ($R[rs_1]$  as integer) | 
| $\textbf{xor}$ | $rd$ $rs_1$  $rs_2$  $i$ | sets $rd$ to the bitwise XOR of $R[rs_1]$ and $(R[rs_2] + i)$ | 
| $\textbf{and}$ | $rd$ $rs_1$  $rs_2$  $i$ | sets $rd$ to the bitwise AND of $R[rs_1]$ and $(R[rs_2] + i)$| 
| $\textbf{or}$ | $rd$ $rs_1$  $rs_2$  $i$ | sets $rd$ to the bitwise OR of $R[rs_1]$ and $(R[rs_2] + i)$| 
| $\textbf{beq}$ | $rs_1$  $rs_2$  $i$ | branches to $pc+i$ if $(R[rs_1] = R[rs_2])$ (signed comparison)| 
| $\textbf{bne}$ | $rs_1$  $rs_2$  $i$ | branches  to $pc+i$ if $(R[rs_1] \not= R[rs_2])$ (signed comparison)| 
| $\textbf{blt}$ | $rs_1$  $rs_2$  $i$ | branches to $pc+i$ if $(R[rs_1] < R[rs_2])$ (signed comparison)| 
| $\textbf{bge}$ | $rs_1$  $rs_2$  $i$ | branches to $pc+i$ if $(R[rs_1] \geq R[rs_2])$ (signed comparison)| 
| $\textbf{bltu}$ | $rs_1$  $rs_2$  $i$ | branches to $pc+i$ if $(R[rs_1] < R[rs_2])$ (unsigned comparison)| 
| $\textbf{bgeu}$ | $rs_1$  $rs_2$  $i$ | branches to $pc+i$ if $(R[rs_1] \geq R[rs_2])$ (unsigned comparison)| 
| $\textbf{lb}$ | $rd$ $rs_1$  $rs_2$  $i$ | loads the sign extension of the byte at $M[R[rs_1] + i]$ into $rd$| 
| $\textbf{lh}$ | $rd$ $rs_1$  $rs_2$  $i$ | loads the sign extension of the half-word at $M[R[rs_1] + i]$ into $rd$| 
| $\textbf{lw}$ | $rd$ $rs_1$  $rs_2$  $i$ | loads the sign extension of the word at $M[R[rs_1] + i]$ into $rd$| 
| $\textbf{lbu}$ | $rd$ $rs_1$  $rs_2$  $i$ | loads the zero extension of the byte at $M[R[rs_1] + i]$ into $rd$| 
| $\textbf{lhu}$ | $rd$ $rs_1$  $rs_2$  $i$ | loads the zero extension of the half-word at $M[R[rs_1] + i]$ into $rd$| 
| $\textbf{sb}$ | $rs_1$  $rs_2$  $i$ | stores the first byte of $R[rs_2]$ at $M[R[rs_1] + i]$| 
| $\textbf{sh}$ | $rs_1$  $rs_2$  $i$ | stores the first half-word of $R[rs_2]$ at $M[R[rs_1] + i]$| 
| $\textbf{sw}$ | $rs_1$  $rs_2$  $i$ | stores $R[rs_2]$ at $M[R[rs_1] + i]$| 
| $\textbf{jal}$ | $rd$ $rs_1$ $i$ | jumps to $M[R[rs_1] + i]$  and stores $pc+8$ into $rd$| 
| $\textbf{nop}$ |  | no operation | 
| $\textbf{halt}$ |  | halts execution, $pc$ is not updated| 


Each instruction is encoded as a 64-bits long string, starting with 8-bit-long $\textbf{opcode}$ string, followed by a 9-bit-long zero string, three 5-bit-long register selectors for $rd$, $rs_1$, and $rs_1$, and a 32-bit immediate value. 

Table: Binary Encoding of Nexus Virtual Machine Instructions, where $*^m$ denotes any binary string of $m$ bits, and $\langle d \rangle$, $\langle s_1 \rangle$, $\langle s_2 \rangle$, and $\langle i \rangle$ denote respectively the binary representation of the 5-bit-long register selectors $rd$, $rs_1$, $rs_2$, and the 32-bit-long immediate value $i$. 

| Instruction mnemonic| Arguments | Binary Encodings |
| -------- | -------- | -------- |
| $\textbf{nop}$ | | $\begin{array}{llllll} \texttt{0x01}  & \mathtt{*^5} \; \  & \mathtt{*^5} \; \ & \; \mathtt{*^5} \; \  & \mathtt{*^{32}}\end{array}$| 
| $\textbf{halt}$ | | $\begin{array}{llllll} \texttt{0x02}  & \mathtt{*^5} \; \  & \mathtt{*^5} \; \ & \; \mathtt{*^5} \; \  & \mathtt{*^{32}}\end{array}$| 
| $\textbf{jal}$ | $rd$ $rs_1$  $i$ | $\begin{array}{llllll} \texttt{0x10}  & \langle d \rangle  & \langle s_1 \rangle & \; \mathtt{*^5} \; \  & \langle i \rangle\end{array}$| 
| $\textbf{beq}$ | $rs_1$  $rs_2$  $i$ | $\begin{array}{llllll} \texttt{0x11}  & \mathtt{*^5} \;\  & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$| 
| $\textbf{bne}$ | $rs_1$  $rs_2$  $i$ | $\begin{array}{llllll} \texttt{0x12}  & \mathtt{*^5} \; \ & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$| 
| $\textbf{blt}$ | $rs_1$  $rs_2$  $i$ | $\begin{array}{llllll} \texttt{0x13}  & \mathtt{*^5} \; \ & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$| 
| $\textbf{bge}$ | $rs_1$  $rs_2$  $i$ | $\begin{array}{llllll} \texttt{0x14}  & \mathtt{*^5} \; \ & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$| 
| $\textbf{bltu}$ | $rs_1$  $rs_2$  $i$ | $\begin{array}{llllll} \texttt{0x15}  & \mathtt{*^5} \; \ & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$| 
| $\textbf{bgeu}$ | $rs_1$  $rs_2$  $i$ | $\begin{array}{llllll} \texttt{0x16}  & \mathtt{*^5} \; \ & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$| 
| $\textbf{lb}$ | $rd$ $rs_1$  $i$ | $\begin{array}{llllll} \texttt{0x20}  & \langle d \rangle  & \langle s_1 \rangle & \; \mathtt{*^5} \; \  & \langle i \rangle\end{array}$| 
| $\textbf{lh}$ | $rd$ $rs_1$  $i$ | $\begin{array}{llllll} \texttt{0x21}  & \langle d \rangle  & \langle s_1 \rangle & \; \mathtt{*^5} \; \  & \langle i \rangle\end{array}$| 
| $\textbf{lw}$ | $rd$ $rs_1$  $i$ | $\begin{array}{llllll} \texttt{0x22}  & \langle d \rangle  & \langle s_1 \rangle & \; \mathtt{*^5} \; \  & \langle i \rangle\end{array}$| 
| $\textbf{lbu}$ | $rd$ $rs_1$  $i$ | $\begin{array}{llllll} \texttt{0x23}  & \langle d \rangle  & \langle s_1 \rangle & \; \mathtt{*^5} \; \  & \langle i \rangle\end{array}$| 
| $\textbf{lhu}$ | $rd$ $rs_1$  $i$ | $\begin{array}{llllll} \texttt{0x24}  & \langle d \rangle  & \langle s_1 \rangle & \; \mathtt{*^5} \; \  & \langle i \rangle\end{array}$| 
| $\textbf{sb}$ | $rs_1$  $rs_2$  $i$ | $\begin{array}{llllll} \texttt{0x30}  & \mathtt{*^5} \;\  & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$| 
| $\textbf{sh}$ | $rs_1$  $rs_2$  $i$ | $\begin{array}{llllll} \texttt{0x31}  & \mathtt{*^5} \;\  & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$| 
| $\textbf{sw}$ | $rs_1$  $rs_2$  $i$ | $\begin{array}{llllll} \texttt{0x32}  & \mathtt{*^5} \;\  & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$| 
| $\textbf{add}$     | $rd$ $rs_1$  $rs_2$  $i$     |  $\begin{array}{llllll} \texttt{0x40}  & \langle d \rangle  & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$    |
| $\textbf{sub}$     | $rd$ $rs_1$  $rs_2$  $i$     |  $\begin{array}{llllll} \texttt{0x41}  & \langle d \rangle  & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$    |
| $\textbf{slt}$     | $rd$ $rs_1$  $rs_2$  $i$     |  $\begin{array}{llllll} \texttt{0x42}  & \langle d \rangle  & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$    |
| $\textbf{sltu}$     | $rd$ $rs_1$  $rs_2$  $i$     |  $\begin{array}{llllll} \texttt{0x43}  & \langle d \rangle  & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$    |
| $\textbf{sll}$     | $rd$ $rs_1$  $rs_2$  $i$     |  $\begin{array}{llllll} \texttt{0x44}  & \langle d \rangle  & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$    |
| $\textbf{slr}$     | $rd$ $rs_1$  $rs_2$  $i$     |  $\begin{array}{llllll} \texttt{0x45}  & \langle d \rangle  & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$    |
| $\textbf{sra}$     | $rd$ $rs_1$  $rs_2$  $i$     |  $\begin{array}{llllll} \texttt{0x46}  & \langle d \rangle  & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$    |
| $\textbf{or}$     | $rd$ $rs_1$  $rs_2$  $i$     |  $\begin{array}{llllll} \texttt{0x47}  & \langle d \rangle  & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$    |
| $\textbf{and}$     | $rd$ $rs_1$  $rs_2$  $i$     |  $\begin{array}{llllll} \texttt{0x48}  & \langle d \rangle  & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$    |
| $\textbf{xor}$     | $rd$ $rs_1$  $rs_2$  $i$     |  $\begin{array}{llllll} \texttt{0x49}  & \langle d \rangle  & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$    |
| $\textbf{mul}$     | $rd$ $rs_1$  $rs_2$  $i$     |  $\begin{array}{llllll} \texttt{0x??}  & \langle d \rangle  & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$    |
| $\textbf{div}$     | $rd$ $rs_1$  $rs_2$  $i$     |  $\begin{array}{llllll} \texttt{0x??}  & \langle d \rangle  & \langle s_1 \rangle & \langle s_2 \rangle & \langle i \rangle\end{array}$    |

Compared to RISC-V, Nexus VM instructions are longer (64 bits versus 32 bits) and allow for an additional argument.  One of the advantages of having an additional argument is that it allows for a reduced instruction set. In particular, as noted in the section describing the translation from RISC-V to Nexus VM,  different RISC-V instructions can be emulated with a single Nexus VM instruction.

Though not yet defined in the existing instruction set, we expect to have a special instruction which indicates whether the program halts in an accepting or rejecting state, similarly to the [TinyRAM architecture specification][TinyRAM].

We also do not specify an output tape. Nevertheless, one can easily return arbitrary strings as output by encoding that string in some specific region of the memory before halting in an accepting state.

As we show in the next section, the RISC-V instruction set can be easily compiled to the instruction set of the Nexus VM, by applying a simple translation function to a subset of these instructions. As a result, the Nexus VM can effortlessly support the execution of programs written in high-level programming languages such as Rust and C++. In addition to that, as indicated further below, future versions of the Nexus VM will be able to be *extended* with custom instructions (e.g. SHA-256). 

### Translation from RISC-V to Nexus VM


The syntax of RISC-V instructions supported by the Nexus VM is the following:

$$
\begin{align*}
    %\text{Binary Operators}\\
    i \in&\: \{0..2^{32}\} &\text{Immediate values} \\
    pc \in&\: \{0..2^{32}\} &\text{Program counter} \\
    rd,rs_1,rs_2 \in&\: \{x_0 .. x_{31}\} &\text{Register selectors} \\
    alu    =&\: \textbf{add}
         \mid   \textbf{sub}
         \mid   \textbf{mul}
         \mid   \textbf{div} \\
        \mid&\: \textbf{slt}
         \mid   \textbf{sltu}
         \mid   \textbf{sll}
         \mid   \textbf{srl}
         \mid   \textbf{sra} \\
        \mid&\: \textbf{xor}
         \mid   \textbf{and}
         \mid   \textbf{or}                    & \text{Binary operators} \\
    bcc    =&\: \textbf{beq}
         \mid   \textbf{bne}
         \mid   \textbf{blt}
         \mid   \textbf{bge}
         \mid   \textbf{bltu}
         \mid   \textbf{bgeu}                  & \text{Branch conditions} \\
    ld     =&\: \textbf{lb}
         \mid   \textbf{lh}
         \mid   \textbf{lw}
         \mid   \textbf{lbu}
         \mid   \textbf{lhu}                   & \text{Load operations} \\
    st     =&\: \textbf{sb}
         \mid   \textbf{sh}
         \mid   \textbf{sw}                    & \text{Store operations} \\
    oper
           =&\: \textbf{lui}\;rd\;i            & \text{Load immediate} \\
        \mid&\: \textbf{auipc}\;rd\;i          & \text{Load immediate + PC} \\
        \mid&\: alu\;rd\;\;rs_1\;rs_2          & \text{ALU register-register} \\
        \mid&\: alu\;rd\;\;rs_1\;i             & \text{ALU register-immediate} \\
        \mid&\: \textbf{ebreak}                & \text{Breakpoint} \\
        \mid&\: \textbf{fence}                 & \text{Memory fence} \\
    branch
           =&\: \textbf{jal}\;rd\;i            & \text{Jump and link} \\
        \mid&\: \textbf{jalr}\;rd\;rs_1\;i     & \text{Jump and link register} \\
        \mid&\: bcc\;rs_1\;rs_2\;i             & \text{Conditional branch} \\
    memory
           =&\: ld\;rd\;rs_1\;i                & \text{Load memory} \\
        \mid&\: st\;rs_1\;rs_2\;i              & \text{Store memory} \\
    inst
           =&\: oper                           & \text{Operations} \\
        \mid&\: branch                         & \text{Control transfer} \\
        \mid&\: memory                         & \text{Load and store} \\
        \mid&\: \textbf{ecall}                 & \text{Environment call} \\
        \mid&\: \textbf{unimp}                 & \text{Unimplemented} \\
\end{align*}
$$

These RISC-V instructions can be easily converted to Nexus VM instructions according to:

$$
\begin{align*}
    \mathcal{C}(\textbf{lui}\;rd\;i)   =& \textbf{add}\;rd\;x_0\;x_0\;i \\
    \mathcal{C}(\textbf{auipc}\;rd\;i) =& \textbf{add}\;rd\;x_0\;x_0\;(pc+i) \\
    \mathcal{C}(alu\;rd\;\;rs_1\;rs_2) =& alu\;rd\;rs_1\;rs_2\;0 \\
    \mathcal{C}(alu\;rd\;\;rs_1\;i)    =& alu\;rd\;rs_1\;x_0\;i \\
    \mathcal{C}(\textbf{ebreak})       =& \textbf{nop} \\
    \mathcal{C}(\textbf{fence})        =& \textbf{nop} \\
    \mathcal{C}(\textbf{unimp})        =& \textbf{halt} \\
    \mathcal{C}(bcc\;rs_1\;rs_2\;i) =& bcc\;rs_1\;rs_2\;i \\
    \mathcal{C}(ld\;rs_1\;i) =& ld\;rs_1\;i \\
    \mathcal{C}(st\;rs_1\;rs_2\;i) =& st\;rs_1\;rs_2\;i \\
    \mathcal{C}(\textbf{jal}\;rd\;i) =& \textbf{jal}\;rd\;x_0\;i \\
    \mathcal{C}(\textbf{jalr}\;rd\;rs_1\;i) =& \textbf{jal}\;rd\;rs_1\;i \\
    \end{align*}
$$

Note that, the special RISC-V load immediate instructions ($\textbf{lui}$ and $\textbf{auipc}$), are a result of the fixed 32-bit encoding of instructions. The Nexus VM relaxes this constraint allowing for a reduced instruction set.

### Nexus Virtual Machine Initialization

Initially, the memory is assumed to only contain undefined values and all the general-purpose registers are set to 0. The program counter $pc$ is also set to $\mathtt{0x1000}$. Although the current version of the Nexus VM does not yet support input and auxiliary tapes, these will be eventually implemented and initialized with the contents of the public and auxiliary inputs for the program. The program itself is provided to the Nexus VM via a file in a Executable and Linkable Format (ELF) encoded according to the RV32I Instruction Set in the *Volume I, Unprivileged Specification version 20191213* in the [The RISC-V Instruction Set Manual](https://drive.google.com/file/d/1s0lZxUZaa7eV_O0_WsZzaurFLLww7ou5/view?usp=drive_link). 

In order to load the ELF file into the Nexus VM memory, the RISC-V assembly code provided in the ELF file based on 32-bit-long RV32I instruction set is first translated to Nexus VM 64-bit-long instruction set following the translation process described in the previous section. Next each instruction in the program is loaded one at a time into the memory starting at address $\mathtt{0x1000}$.


### Nexus Virtual Machine Extensions

While the universality of the current instruction set allows for executing any program on the Nexus VM, the translation process may yield inefficient programs due to the limited instruction set of the Nexus VM. As a result, proving the correctness of such computations within the Nexus zkVM may become infeasible for more complex programs. The cost of such an abstraction may be multiplied by more than a $1000$ factor for functions such as the SHA-256 circuit.

To deal with such scenarios, the Nexus Virtual Machine is being  designed with extensability in mind in order to enable the addition of custom instructions for more complex functions, such as hashing and signature verification.

Currently, the Nexus Virtual Machine uses universal circuits to simulate the whole CPU and this unfortunately increases the complexity of the Nexus Proof System with each additional instruction.

Nevertheless, as described in the Nexus whitepaper, we will soon be switching to a *non-uniform* computation model based on recent advances in folding and accumulation techniques (e.g.,  [[KS22](#References)], [[BC23](#References)]), via the concept of *zkVM co-processors*. In the new model, the cost of proving custom co-processor extensions of the NVM instruction set is only occurs when that particular co-processor is executed by the program.

<center>
![nvm-architecture-coprocessors](/images/nvm-coprocessors.svg)
</center>

The main advantage of using co-processors is that it maintains a developer-friendly CPU abstraction while efficiently allowing for the addition of more complex functions.


Though we first expect to implement these special functions as part of the Nexus VM instruction set, we do intend to eventually support user-defined co-processors written as as CCS circuits [[STW23](#References)] that could be provided as input to the Nexus zkVM.  we expect to first implement these special functions as part of the Nexus VM instruction set.
CCS circuits are a generalization of R1CS [[GGPR13](#References)], Plonkish [[GWC19; CBBZ23](#References)], and AIR [[BBHR19; Sta21; BCKL22](#References)].

## Nexus Proof System

The second main component of the Nexus zkVM is the Nexus Proof System, which provides proofs of correctness for any computation being run on the Nexus VM. In order to realize this goal and be able to support arbitrarily large computations, the Nexus Proof System relies on modern recursive zero-knowledge proof systems such as folding and accumulation schemes [[KST22; KS22; BC23](#References)] to achieve a high level of parallelization.

Let $P$ be a program that has been compiled to the Nexus VM, possibly with access to co-processors.  The proof generation process for $P$ has four main steps: 
1. Nexus zkVM initialization;
2. Program execution;
3. Proof accumulation; and
4. Proof compression.

The following subsections provide an overview of each of these  components.

### Initialization

Let $P$ be a program that which we execute in a verifiable manner. As described above, before loading $P$ into the memory starting at address $\mathtt{0x1000}$, the Nexus VM initially sets the contents of its global-purpose registers to 0 and the value of each memory location is assumed to be undefined. 

In order to enforce the consistency of the memory throughout the execution of the program $P$, the Nexus zkVM currently uses Merkle Trees [[M87](#References)] for memory checking together with the Poseidon hash function [[GKR21](#References)]. In this method, we compute a Merkle root associated with the current contents of the memory and we update its value whenever there is a change to the contents of the memory.

Since the memory for the Nexus VM contains $2^{32}$ bytes, we associate leafs to 256-bit-long strings (i.e., 32 bytes) and then use a Merkle binary tree with 27 levels to describe its contents. In order to compute the Merkle root for the initial memory, we compute a default value for each tree level starting from the leaves and ending with the Merkle root. To compute the default value for a given level, we simply compute the hash of the concatenation of two default values for the level below.

Once the Merkle Root for the initial state is computed, the Nexus zkVM starts loading the program $P$ one instruction at a time, updating the Merkle Tree Root accordingly after each memory update. 

Finally, once $P$ is fully loaded into the memory, we use the Merkle Root for the current state of the memory as the public input to the execution step of the proof system.

### Program execution

After receiving a Merkle proof from the initialization step with a Merkle proof for the initial memory state with the program loaded at address $\mathtt{0x1000}$, the Nexus zkVM runs the program on the Nexus VM and generates a full execution trace for it. This execution trace is then passed to the proof accumulation step, as indicated in the following diagram taken from the Nexus whitepaper, where each step $F$ denotes one step of the Nexus VM.

![zkvm-architecture](/images/execution-sequence.svg)

### Proof accumulation

In order to enable a high-level of parallelization without impacting the efficiency of the scheme, the Nexus zkVM uses proof accumulation (without SNARKs), represented by the IVC step in the diagram above. The main advantage of using such schemes is that it realizes the notion of Proof-Carrying Data (PCD) [CT10], a generalization of IVC to the distributed setting.

In the current version of Nexus zkVM, this step makes use of  the Nova folding scheme [[KST22](#References)] over a cycle of elliptic curves.

As mentioned in the whitepaper, this is the most computationally expensive part of the proof generation, since each folding step requires computing a single multi-scalar multiplication (MSM). Nevertheless, this computation is highly parallelizable. 


### Proof compression

Despite being highly parallelizable, the accumulated proof generated in the IVC phase is quite large, which is undesirable in practice. Besides their sizes, such proofs are also not easily verifiable by other systems. For these reasons, the final step of the proof generation is to compress the accumulated proof with a sequence of succinct (zero-knowledge) Non-Interactive Arguments of Knowledge or (zk)-SNARKs for short.


## Nexus zkVM costs

Most of instructions of the Nexus VM instruction set can be implemented quite efficiently requiring less than 2000 constraints in total. The main exception are memory operations, which require expensive Merkle proof computations. More precisely, in the case of a memory update, one needs to compute 3 Merkle proofs, one to read the current instruction from memory, one to read the current contents of the memory location, and one to update that memory location. Each of the Merkle proofs require about 10000 constraints (about 400 constraints for each of the 27 levels of the Merkle tree).

Since the current version of the Nexus VM uses a universal model of computation, the total cost of each proof accumulation step is currently around 32000 constraints, which is quite inefficient. However, we expect to significantly improve these costs by using better memory checking techniques and a non-uniform model of computation. The use of co-processors also has the pontential to significantly improve the efficiency of the Nexus Proof System. 

# References

[[BBHR19](https://www.iacr.org/archive/crypto2019/116940201/116940201.pdf)] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. “Scalable zero knowledge with no trusted setup”. In CRYPTO 2019.

[[BC23](https://eprint.iacr.org/2023/620)] Benedikt Bünz and Binyi Chen. “Protostar: Generic efficient accumulation/folding for special sound protocols”. In: Cryptology ePrint Archive (2023)

[[BCKL22](https://eprint.iacr.org/2022/1542)] Eli Ben-Sasson, Dan Carmon, Swastik Kopparty, and David Levit. “Scalable and transparent proofs over all large fields, via elliptic curves”. In: Electronic Colloquium on Computational Complexity, Report. Vol. 110. 2022, p. 2022

[[CGTV20](https://www.scipr-lab.org/doc/TinyRAM-spec-2.000.pdf)] Eli Ben-Sasson Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. “TinyRAM Architecture Specification v2. 000”. (2020) 

[[CBBZ23](https://eprint.iacr.org/2022/1355)] Binyi Chen, Benedikt Bünz, Dan Boneh, and Zhenfei Zhang. “Hyperplonk: Plonk with linear-time prover and high-degree custom gates”. In EUROCRYPT 2023. 

[[CT10](https://projects.csail.mit.edu/pcd/)] Alessandro Chiesa and Eran Tromer. “Proof-Carrying Data and Hearsay Arguments from Signature Cards.” In: ICS. Vol. 10. 2010, pp. 310–331

[[GGPR13](https://eprint.iacr.org/2012/215.pdf)] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. “Quadratic span programs and succinct NIZKs without PCPs”. In EUROCRYPT 2013.

[[GKR21](https://www.usenix.org/system/files/sec21-grassi.pdf)] Lorenzo Grassi, Dmitry Khovratovich, Christian Rechberger, Arnab Roy, and Markus Schofnegger. “Poseidon: A new hash function for Zero-Knowledge proof systems”. In: 30th USENIX Security Symposium (USENIX Security 21). 2021, pp. 519–535

[[GWC19](https://eprint.iacr.org/2019/953)] Ariel Gabizon, Zachary J Williamson, and Oana Ciobotaru. “Plonk: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge”. In: Cryptology ePrint Archive (2019)

[[KS22](https://eprint.iacr.org/2022/1758)] Abhiram Kothapalli and Srinath Setty. “SuperNova: Proving universal machine executions without universal circuits”. In: Cryptology ePrint Archive (2022)

[[KST22](https://eprint.iacr.org/2021/370)] Abhiram Kothapalli, Srinath Setty, and Ioanna Tzialla. “Nova: Recursive zero-knowledge arguments from folding schemes”. In CRYPTO 2022.

[[M87](https://link.springer.com/chapter/10.1007/3-540-48184-2_32)] Ralph C Merkle. “A digital signature based on a conventional encryption function”. In CRYPTO 1987.

[[Sta21](https://eprint.iacr.org/2021/582)] StarkWare. ethSTARK Documentation. Cryptology ePrint Archive, Paper 2021/582. 

[[STW23](https://eprint.iacr.org/2023/552)] Srinath Setty, Justin Thaler, and Riad Wahby. “Customizable constraint systems for succinct arguments”. In: Cryptology ePrint Archive (2023)

[[Val08](https://link.springer.com/chapter/10.1007/978-3-540-78524-8_1)] Paul Valiant. “Incrementally verifiable computation or proofs of knowledge imply time/space efficiency”. In TCC 2008.

[[WLPA14](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2014/EECS-2014-54.pdf)] Andrew Waterman, Yunsup Lee, David A Patterson, and Krste Asanovic. “The RISC-V instruction set manual, volume I: User-level ISA, version 2.0”. In: EECS Department, University of California, Berkeley, Tech. Rep. UCB/EECS-2014-54 (2014)

    
[TinyRAM]: (https://www.scipr-lab.org/doc/TinyRAM-spec-2.000.pdf)
[RISCZero]: (https://www.risczero.com)
[zkMISP]: (https://whitepaper.zkm.io/whitepaper1.2.pdf)

